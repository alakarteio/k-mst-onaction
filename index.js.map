{"version":3,"file":"index.js","sources":["src/helpers/take.js","src/runners/runArray.js","src/runners/runFunction.js","src/getAction.js","src/middleware.js"],"sourcesContent":["import { isRegExp, isString, isFunction } from 'lodash'\nimport pathToRegexp from 'path-to-regexp'\n\nconst take = (match, callback) => (action, tree) => {\n  const isMatching = ( // test matching\n    // to a string converted to regexp\n    (\n      isString(match) &&\n      pathToRegexp(match, [], { sensitive: true }).exec(action.fullpath) !== null\n    )\n    // to a function\n    || (\n      isFunction(match) &&\n      match(action, tree)\n    )\n    // to a regexp\n    || (\n      isRegExp(match) &&\n      action.fullpath.match(match)\n    )\n  )\n\n  if (isMatching) return callback(action, tree)\n  return false\n}\n\nconst ended = (match, callback) => (action, tree) => {\n  if (action.ended) return take(match, callback)(action, tree)\n  return false\n}\n\ntake.ended = ended\n\nexport default take\n","export default (dispatch, action, tree) => {\n  dispatch.forEach(runner => runner(action, tree))\n}\n","import { isArray } from 'lodash'\n\nexport default (dispatch, action, tree) => {\n  const dispatchCall = dispatch(action, tree)\n  if (!dispatchCall) return\n  if (isArray(dispatchCall)) dispatchCall.forEach(runner => runner(action, tree))\n}\n","import { getPath } from 'mobx-state-tree'\n\nexport default (call) => {\n  const {\n    name,\n    type,\n    context,\n    args,\n  } = call\n\n  const path = getPath(context)\n  const fullpath = `${path}/${name}`\n\n  const action = {\n    fullpath,\n    path,\n    name,\n    args,\n  }\n\n  switch (type) {\n    case 'process_return': // mobx-state-tree v1.0 and older\n    case 'flow_return': return { ...action, ended: true }\n    case 'action': return action\n    default: return undefined\n  }\n}\n","import { isArray, isFunction } from 'lodash'\nimport { runArray, runFunction } from './runners'\nimport getAction from './getAction'\n\nconst run = dispatch => (action, tree) => {\n  if (isFunction(dispatch)) return runFunction(dispatch, action, tree)\n  if (isArray(dispatch)) return runArray(dispatch, action, tree)\n\n  throw new Error('[k-mst-onaction] unknow dispatch type')\n}\n\nexport default (dispatch) => {\n  const runDispatch = run(dispatch)\n\n  return (call, next) => {\n    const action = getAction(call)\n\n    if (action) runDispatch(action, call.tree)\n\n    return next(call)\n  }\n}\n"],"names":["take","match","callback","action","tree","pathToRegexp","sensitive","exec","fullpath","isRegExp","ended","dispatch","forEach","runner","dispatchCall","isArray","call","name","type","context","args","path","getPath","run","isFunction","runFunction","runArray","Error","runDispatch","next","getAction"],"mappings":"kZAGA,IAAMA,EAAO,SAACC,EAAOC,UAAa,SAACC,EAAQC,uBAI5BH,IAC8D,OAAvEI,EAAaJ,MAAaK,WAAW,IAAQC,KAAKJ,EAAOK,wBAI9CP,IACXA,EAAME,EAAQC,IAIdK,WAASR,IACTE,EAAOK,SAASP,MAAMA,KAIHC,EAASC,EAAQC,KAS1CJ,EAAKU,MALS,SAACT,EAAOC,UAAa,SAACC,EAAQC,WACtCD,EAAOO,OAAcV,EAAKC,EAAOC,EAAZF,CAAsBG,EAAQC,KC3BzD,eAAgBO,EAAUR,EAAQC,KACvBQ,QAAQ,mBAAUC,EAAOV,EAAQC,iBCC5BO,EAAUR,EAAQC,OAC1BU,EAAeH,EAASR,EAAQC,GACjCU,GACDC,UAAQD,IAAeA,EAAaF,QAAQ,mBAAUC,EAAOV,EAAQC,ilCCH3DY,OAEZC,EAIED,EAJFC,KACAC,EAGEF,EAHFE,KACAC,EAEEH,EAFFG,QACAC,EACEJ,EADFI,KAGIC,EAAOC,UAAQH,GAGfhB,YAFckB,MAAQJ,+BASpBC,OACD,qBACA,0BAA2Bf,GAAQO,OAAO,QAC1C,gBAAiBP,mBCnBpBoB,EAAM,mBAAY,SAACpB,EAAQC,MAC3BoB,aAAWb,GAAW,OAAOc,EAAYd,EAAUR,EAAQC,MAC3DW,UAAQJ,GAAW,OAAOe,EAASf,EAAUR,EAAQC,SAEnD,IAAIuB,MAAM,8DAGFhB,OACRiB,EAAcL,EAAIZ,UAEjB,SAACK,EAAMa,OACN1B,EAAS2B,EAAUd,UAErBb,GAAQyB,EAAYzB,EAAQa,EAAKZ,MAE9ByB,EAAKb"}